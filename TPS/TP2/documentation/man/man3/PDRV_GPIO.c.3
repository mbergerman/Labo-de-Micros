.TH "drivers/PDRV_GPIO.c" 3 "Mon Sep 13 2021" "TP2_G1" \" -*- nroff -*-
.ad l
.nh
.SH NAME
drivers/PDRV_GPIO.c \- GPIO driver\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'MK64F12\&.h'\fP
.br
\fC#include 'PDRV_GPIO\&.h'\fP
.br
\fC#include 'hardware\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSIM_SCGC5_PORT_MASK\fP   0x3E00"
.br
.ti -1c
.RI "#define \fBSIM_SCGC5_PORT\fP(port,  b)   (((uint32_t)(((uint32_t)(b)) << (9+port))) & \fBSIM_SCGC5_PORT_MASK\fP)"
.br
.ti -1c
.RI "#define \fBPORTX_IRQn\fP(p)   (\fBPORTA_IRQn\fP+p)"
.br
.ti -1c
.RI "#define \fBPINS_PER_PORT\fP   32"
.br
.ti -1c
.RI "#define \fBARRAY_SIZE\fP   (FSL_FEATURE_SOC_PORT_COUNT*\fBPINS_PER_PORT\fP)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBgpioMode\fP (\fBpin_t\fP pin, uint8_t mode)"
.br
.RI "Configures the specified pin to behave either as an input or an output\&. "
.ti -1c
.RI "bool \fBgpioIRQ\fP (\fBpin_t\fP pin, uint8_t irqMode, \fBpinIrqFun_t\fP irqFun)"
.br
.RI "Configures how the pin reacts when an IRQ event ocurrs\&. "
.ti -1c
.RI "void \fBgpioWrite\fP (\fBpin_t\fP pin, bool value)"
.br
.RI "Write a HIGH or a LOW value to a digital pin\&. "
.ti -1c
.RI "void \fBgpioToggle\fP (\fBpin_t\fP pin)"
.br
.RI "Toggle the value of a digital pin (HIGH<->LOW) "
.ti -1c
.RI "bool \fBgpioRead\fP (\fBpin_t\fP pin)"
.br
.RI "Reads the value from a specified digital pin, either HIGH or LOW\&. "
.ti -1c
.RI "\fB__ISR__\fP \fBPORTA_IRQHandler\fP (void)"
.br
.ti -1c
.RI "\fB__ISR__\fP \fBPORTB_IRQHandler\fP (void)"
.br
.ti -1c
.RI "\fB__ISR__\fP \fBPORTC_IRQHandler\fP (void)"
.br
.ti -1c
.RI "\fB__ISR__\fP \fBPORTD_IRQHandler\fP (void)"
.br
.ti -1c
.RI "\fB__ISR__\fP \fBPORTE_IRQHandler\fP (void)"
.br
.in -1c
.SH "Detailed Description"
.PP 
GPIO driver\&. 


.PP
\fBAuthor:\fP
.RS 4
Grupo 1 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define ARRAY_SIZE   (FSL_FEATURE_SOC_PORT_COUNT*\fBPINS_PER_PORT\fP)"

.SS "#define PINS_PER_PORT   32"

.SS "#define PORTX_IRQn(p)   (\fBPORTA_IRQn\fP+p)"

.SS "#define SIM_SCGC5_PORT(port, b)   (((uint32_t)(((uint32_t)(b)) << (9+port))) & \fBSIM_SCGC5_PORT_MASK\fP)"

.SS "#define SIM_SCGC5_PORT_MASK   0x3E00"

.SH "Function Documentation"
.PP 
.SS "bool gpioIRQ (\fBpin_t\fP pin, uint8_t irqMode, \fBpinIrqFun_t\fP irqFun)"

.PP
Configures how the pin reacts when an IRQ event ocurrs\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpin\fP the pin whose IRQ mode you wish to set (according PORTNUM2PIN) 
.br
\fIirqMode\fP disable, risingEdge, fallingEdge or bothEdges 
.br
\fIirqFun\fP function to call on pin event 
.RE
.PP
\fBReturns:\fP
.RS 4
Registration succeed 
.RE
.PP

.SS "void gpioMode (\fBpin_t\fP pin, uint8_t mode)"

.PP
Configures the specified pin to behave either as an input or an output\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpin\fP the pin whose mode you wish to set (according PORTNUM2PIN) 
.br
\fImode\fP INPUT, OUTPUT, INPUT_PULLUP or INPUT_PULLDOWN\&. 
.RE
.PP
!! 
.SS "bool gpioRead (\fBpin_t\fP pin)"

.PP
Reads the value from a specified digital pin, either HIGH or LOW\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpin\fP the pin to read (according PORTNUM2PIN) 
.RE
.PP
\fBReturns:\fP
.RS 4
HIGH or LOW 
.RE
.PP

.SS "void gpioToggle (\fBpin_t\fP pin)"

.PP
Toggle the value of a digital pin (HIGH<->LOW) 
.PP
\fBParameters:\fP
.RS 4
\fIpin\fP the pin to toggle (according PORTNUM2PIN) 
.RE
.PP

.SS "void gpioWrite (\fBpin_t\fP pin, bool value)"

.PP
Write a HIGH or a LOW value to a digital pin\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpin\fP the pin to write (according PORTNUM2PIN) 
.br
\fIval\fP Desired value (HIGH or LOW) 
.RE
.PP

.SS "\fBWEAK\fP void PORTA_IRQHandler (void)"

.SS "\fBWEAK\fP void PORTB_IRQHandler (void)"

.SS "\fBWEAK\fP void PORTC_IRQHandler (void)"

.SS "\fBWEAK\fP void PORTD_IRQHandler (void)"

.SS "\fBWEAK\fP void PORTE_IRQHandler (void)"

.SH "Author"
.PP 
Generated automatically by Doxygen for TP2_G1 from the source code\&.
