.TH "SDK/CMSIS/mpu_armv8.h" 3 "Mon Sep 13 2021" "TP2_G1" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SDK/CMSIS/mpu_armv8.h
.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBARM_MPU_Region_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBARM_MPU_ARMV8_H\fP"
.br
.ti -1c
.RI "#define \fBARM_MPU_ATTR_DEVICE\fP   ( 0U )"
.br
.RI "Attribute for device memory (outer only) "
.ti -1c
.RI "#define \fBARM_MPU_ATTR_NON_CACHEABLE\fP   ( 4U )"
.br
.RI "Attribute for non-cacheable, normal memory\&. "
.ti -1c
.RI "#define \fBARM_MPU_ATTR_MEMORY_\fP(NT,  WB,  RA,  WA)   (((NT & 1U) << 3U) | ((WB & 1U) << 2U) | ((RA & 1U) << 1U) | (WA & 1U))"
.br
.RI "Attribute for normal memory (outer and inner) "
.ti -1c
.RI "#define \fBARM_MPU_ATTR_DEVICE_nGnRnE\fP   (0U)"
.br
.RI "Device memory type non Gathering, non Re-ordering, non Early Write Acknowledgement\&. "
.ti -1c
.RI "#define \fBARM_MPU_ATTR_DEVICE_nGnRE\fP   (1U)"
.br
.RI "Device memory type non Gathering, non Re-ordering, Early Write Acknowledgement\&. "
.ti -1c
.RI "#define \fBARM_MPU_ATTR_DEVICE_nGRE\fP   (2U)"
.br
.RI "Device memory type non Gathering, Re-ordering, Early Write Acknowledgement\&. "
.ti -1c
.RI "#define \fBARM_MPU_ATTR_DEVICE_GRE\fP   (3U)"
.br
.RI "Device memory type Gathering, Re-ordering, Early Write Acknowledgement\&. "
.ti -1c
.RI "#define \fBARM_MPU_ATTR\fP(O,  I)   (((O & 0xFU) << 4U) | (((O & 0xFU) != 0U) ? (I & 0xFU) : ((I & 0x3U) << 2U)))"
.br
.RI "Memory Attribute\&. "
.ti -1c
.RI "#define \fBARM_MPU_SH_NON\fP   (0U)"
.br
.RI "Normal memory non-shareable\&. "
.ti -1c
.RI "#define \fBARM_MPU_SH_OUTER\fP   (2U)"
.br
.RI "Normal memory outer shareable\&. "
.ti -1c
.RI "#define \fBARM_MPU_SH_INNER\fP   (3U)"
.br
.RI "Normal memory inner shareable\&. "
.ti -1c
.RI "#define \fBARM_MPU_AP_\fP(RO,  NP)   (((RO & 1U) << 1U) | (NP & 1U))"
.br
.RI "Memory access permissions\&. "
.ti -1c
.RI "#define \fBARM_MPU_RBAR\fP(BASE,  SH,  RO,  NP,  XN)"
.br
.RI "Region Base Address Register value\&. "
.ti -1c
.RI "#define \fBARM_MPU_RLAR\fP(LIMIT,  IDX)"
.br
.RI "Region Limit Address Register value\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_Enable\fP (uint32_t MPU_Control)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_Disable\fP (void)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_SetMemAttrEx\fP (MPU_Type *mpu, uint8_t idx, uint8_t attr)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_SetMemAttr\fP (uint8_t idx, uint8_t attr)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_ClrRegionEx\fP (MPU_Type *mpu, uint32_t rnr)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_ClrRegion\fP (uint32_t rnr)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_SetRegionEx\fP (MPU_Type *mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_SetRegion\fP (uint32_t rnr, uint32_t rbar, uint32_t rlar)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBorderedCpy\fP (volatile uint32_t *dst, const uint32_t *\fB__RESTRICT\fP src, uint32_t len)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_LoadEx\fP (MPU_Type *mpu, uint32_t rnr, \fBARM_MPU_Region_t\fP const *table, uint32_t cnt)"
.br
.ti -1c
.RI "\fB__STATIC_INLINE\fP void \fBARM_MPU_Load\fP (uint32_t rnr, \fBARM_MPU_Region_t\fP const *table, uint32_t cnt)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ARM_MPU_AP_(RO, NP)   (((RO & 1U) << 1U) | (NP & 1U))"

.PP
Memory access permissions\&. 
.PP
\fBParameters:\fP
.RS 4
\fIRO\fP Read-Only: Set to 1 for read-only memory\&. 
.br
\fINP\fP Non-Privileged: Set to 1 for non-privileged memory\&. 
.RE
.PP

.SS "#define ARM_MPU_ARMV8_H"

.SS "#define ARM_MPU_ATTR(O, I)   (((O & 0xFU) << 4U) | (((O & 0xFU) != 0U) ? (I & 0xFU) : ((I & 0x3U) << 2U)))"

.PP
Memory Attribute\&. 
.PP
\fBParameters:\fP
.RS 4
\fIO\fP Outer memory attributes 
.br
\fII\fP O == ARM_MPU_ATTR_DEVICE: Device memory attributes, else: Inner memory attributes 
.RE
.PP

.SS "#define ARM_MPU_ATTR_DEVICE   ( 0U )"

.PP
Attribute for device memory (outer only) 
.SS "#define ARM_MPU_ATTR_DEVICE_GRE   (3U)"

.PP
Device memory type Gathering, Re-ordering, Early Write Acknowledgement\&. 
.SS "#define ARM_MPU_ATTR_DEVICE_nGnRE   (1U)"

.PP
Device memory type non Gathering, non Re-ordering, Early Write Acknowledgement\&. 
.SS "#define ARM_MPU_ATTR_DEVICE_nGnRnE   (0U)"

.PP
Device memory type non Gathering, non Re-ordering, non Early Write Acknowledgement\&. 
.SS "#define ARM_MPU_ATTR_DEVICE_nGRE   (2U)"

.PP
Device memory type non Gathering, Re-ordering, Early Write Acknowledgement\&. 
.SS "#define ARM_MPU_ATTR_MEMORY_(NT, WB, RA, WA)   (((NT & 1U) << 3U) | ((WB & 1U) << 2U) | ((RA & 1U) << 1U) | (WA & 1U))"

.PP
Attribute for normal memory (outer and inner) 
.PP
\fBParameters:\fP
.RS 4
\fINT\fP Non-Transient: Set to 1 for non-transient data\&. 
.br
\fIWB\fP Write-Back: Set to 1 to use write-back update policy\&. 
.br
\fIRA\fP Read Allocation: Set to 1 to use cache allocation on read miss\&. 
.br
\fIWA\fP Write Allocation: Set to 1 to use cache allocation on write miss\&. 
.RE
.PP

.SS "#define ARM_MPU_ATTR_NON_CACHEABLE   ( 4U )"

.PP
Attribute for non-cacheable, normal memory\&. 
.SS "#define ARM_MPU_RBAR(BASE, SH, RO, NP, XN)"
\fBValue:\fP
.PP
.nf
((BASE & MPU_RBAR_BASE_Pos) | \
  ((SH << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk) | \
  ((ARM_MPU_AP_(RO, NP) << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk) | \
  ((XN << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk))
.fi
.PP
Region Base Address Register value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIBASE\fP The base address bits [31:5] of a memory region\&. The value is zero extended\&. Effective address gets 32 byte aligned\&. 
.br
\fISH\fP Defines the Shareability domain for this memory region\&. 
.br
\fIRO\fP Read-Only: Set to 1 for a read-only memory region\&. 
.br
\fINP\fP Non-Privileged: Set to 1 for a non-privileged memory region\&.  XN eXecute Never: Set to 1 for a non-executable memory region\&. 
.RE
.PP

.SS "#define ARM_MPU_RLAR(LIMIT, IDX)"
\fBValue:\fP
.PP
.nf
((LIMIT & MPU_RLAR_LIMIT_Msk) | \
  ((IDX << MPU_RLAR_AttrIndx_Pos) & MPU_RLAR_AttrIndx_Msk) | \
  (MPU_RLAR_EN_Msk))
.fi
.PP
Region Limit Address Register value\&. 
.PP
\fBParameters:\fP
.RS 4
\fILIMIT\fP The limit address bits [31:5] for this memory region\&. The value is one extended\&. 
.br
\fIIDX\fP The attribute index to be associated with this memory region\&. 
.RE
.PP

.SS "#define ARM_MPU_SH_INNER   (3U)"

.PP
Normal memory inner shareable\&. 
.SS "#define ARM_MPU_SH_NON   (0U)"

.PP
Normal memory non-shareable\&. 
.SS "#define ARM_MPU_SH_OUTER   (2U)"

.PP
Normal memory outer shareable\&. 
.SH "Function Documentation"
.PP 
.SS "\fB__STATIC_INLINE\fP void ARM_MPU_ClrRegion (uint32_t rnr)"
Clear and disable the given MPU region\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrnr\fP Region number to be cleared\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_ClrRegionEx (MPU_Type * mpu, uint32_t rnr)"
Clear and disable the given MPU region of the given MPU\&. 
.PP
\fBParameters:\fP
.RS 4
\fImpu\fP Pointer to MPU to be used\&. 
.br
\fIrnr\fP Region number to be cleared\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_Disable (void)"
Disable the MPU\&. 
.SS "\fB__STATIC_INLINE\fP void ARM_MPU_Enable (uint32_t MPU_Control)"
Enable the MPU\&. 
.PP
\fBParameters:\fP
.RS 4
\fIMPU_Control\fP Default access permissions for unconfigured regions\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_Load (uint32_t rnr, \fBARM_MPU_Region_t\fP const * table, uint32_t cnt)"
Load the given number of MPU regions from a table\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrnr\fP First region number to be configured\&. 
.br
\fItable\fP Pointer to the MPU configuration table\&. 
.br
\fIcnt\fP Amount of regions to be configured\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_LoadEx (MPU_Type * mpu, uint32_t rnr, \fBARM_MPU_Region_t\fP const * table, uint32_t cnt)"
Load the given number of MPU regions from a table to the given MPU\&. 
.PP
\fBParameters:\fP
.RS 4
\fImpu\fP Pointer to the MPU registers to be used\&. 
.br
\fIrnr\fP First region number to be configured\&. 
.br
\fItable\fP Pointer to the MPU configuration table\&. 
.br
\fIcnt\fP Amount of regions to be configured\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_SetMemAttr (uint8_t idx, uint8_t attr)"
Set the memory attribute encoding\&. 
.PP
\fBParameters:\fP
.RS 4
\fIidx\fP The attribute index to be set [0-7] 
.br
\fIattr\fP The attribute value to be set\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_SetMemAttrEx (MPU_Type * mpu, uint8_t idx, uint8_t attr)"
Set the memory attribute encoding to the given MPU\&. 
.PP
\fBParameters:\fP
.RS 4
\fImpu\fP Pointer to the MPU to be configured\&. 
.br
\fIidx\fP The attribute index to be set [0-7] 
.br
\fIattr\fP The attribute value to be set\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_SetRegion (uint32_t rnr, uint32_t rbar, uint32_t rlar)"
Configure the given MPU region\&. 
.PP
\fBParameters:\fP
.RS 4
\fIrnr\fP Region number to be configured\&. 
.br
\fIrbar\fP Value for RBAR register\&. 
.br
\fIrlar\fP Value for RLAR register\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void ARM_MPU_SetRegionEx (MPU_Type * mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)"
Configure the given MPU region of the given MPU\&. 
.PP
\fBParameters:\fP
.RS 4
\fImpu\fP Pointer to MPU to be used\&. 
.br
\fIrnr\fP Region number to be configured\&. 
.br
\fIrbar\fP Value for RBAR register\&. 
.br
\fIrlar\fP Value for RLAR register\&. 
.RE
.PP

.SS "\fB__STATIC_INLINE\fP void orderedCpy (volatile uint32_t * dst, const uint32_t *\fB__RESTRICT\fP src, uint32_t len)"
Memcopy with strictly ordered memory access, e\&.g\&. for register targets\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdst\fP Destination data is copied to\&. 
.br
\fIsrc\fP Source data is copied from\&. 
.br
\fIlen\fP Amount of data words to be copied\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for TP2_G1 from the source code\&.
