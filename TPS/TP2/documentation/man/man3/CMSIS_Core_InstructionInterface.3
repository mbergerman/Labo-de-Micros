.TH "CMSIS_Core_InstructionInterface" 3 "Mon Sep 13 2021" "TP2_G1" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CMSIS_Core_InstructionInterface
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__NOP\fP   __nop"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP   __wfi"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP   __wfe"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP   __sev"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__ISB\fP()"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DSB\fP()"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DMB\fP()"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "#define \fB__REV\fP   __rev"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "#define \fB__ROR\fP   __ror"
.br
.RI "Rotate Right in unsigned value (32 bit) "
.ti -1c
.RI "#define \fB__BKPT\fP(value)   __breakpoint(value)"
.br
.RI "Breakpoint\&. "
.ti -1c
.RI "#define \fB__CLZ\fP   __clz"
.br
.RI "Count leading zeros\&. "
.ti -1c
.RI "#define \fB__CMSIS_GCC_OUT_REG\fP(r)   '=r' (r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_USE_REG\fP(r)   'r' (r)"
.br
.ti -1c
.RI "#define \fB__NOP\fP   __builtin_arm_nop"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP   __builtin_arm_wfi"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP   __builtin_arm_wfe"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP   __builtin_arm_sev"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__ISB\fP()   __builtin_arm_isb(0xF);"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DSB\fP()   __builtin_arm_dsb(0xF);"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DMB\fP()   __builtin_arm_dmb(0xF);"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "#define \fB__REV\fP(value)   __builtin_bswap32(value)"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "#define \fB__REV16\fP(value)   \fB__ROR\fP(\fB__REV\fP(value), 16)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "#define \fB__REVSH\fP(value)   (int16_t)__builtin_bswap16(value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "#define \fB__BKPT\fP(value)   \fB__ASM\fP volatile ('bkpt '#value)"
.br
.RI "Breakpoint\&. "
.ti -1c
.RI "#define \fB__RBIT\fP   __builtin_arm_rbit"
.br
.RI "Reverse bit order of value\&. "
.ti -1c
.RI "#define \fB__CLZ\fP   (uint8_t)__builtin_clz"
.br
.RI "Count leading zeros\&. "
.ti -1c
.RI "#define \fB__CMSIS_GCC_OUT_REG\fP(r)   '=r' (r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_RW_REG\fP(r)   '+r' (r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_USE_REG\fP(r)   'r' (r)"
.br
.ti -1c
.RI "#define \fB__NOP\fP()   \fB__ASM\fP volatile ('nop')"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP()   \fB__ASM\fP volatile ('wfi')"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP()   \fB__ASM\fP volatile ('wfe')"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP()   \fB__ASM\fP volatile ('sev')"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__BKPT\fP(value)   \fB__ASM\fP volatile ('bkpt '#value)"
.br
.RI "Breakpoint\&. "
.ti -1c
.RI "#define \fB__CLZ\fP   (uint8_t)__builtin_clz"
.br
.RI "Count leading zeros\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fB__attribute__\fP ((section('\&.rev16_text'))) __STATIC_INLINE \fB__ASM\fP uint32_t \fB__REV16\fP(uint32_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "\fB__attribute__\fP ((section('\&.revsh_text'))) __STATIC_INLINE \fB__ASM\fP int16_t \fB__REVSH\fP(int16_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "\fB__attribute__\fP ((always_inline)) \fB__STATIC_INLINE\fP uint32_t \fB__RBIT\fP(uint32_t value)"
.br
.RI "Reverse bit order of value\&. "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP uint32_t \fB__ROR\fP (uint32_t op1, uint32_t op2)"
.br
.RI "Rotate Right in unsigned value (32 bit) "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP int32_t \fB__SSAT\fP (int32_t val, uint32_t \fBsat\fP)"
.br
.RI "Signed Saturate\&. "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP uint32_t \fB__USAT\fP (int32_t val, uint32_t \fBsat\fP)"
.br
.RI "Unsigned Saturate\&. "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP void \fB__ISB\fP (void)"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP void \fB__DSB\fP (void)"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP void \fB__DMB\fP (void)"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP uint32_t \fB__REV\fP (uint32_t value)"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP uint32_t \fB__REV16\fP (uint32_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP int16_t \fB__REVSH\fP (int16_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "\fB__STATIC_FORCEINLINE\fP uint32_t \fB__RBIT\fP (uint32_t value)"
.br
.RI "Reverse bit order of value\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "uint32_t \fBsat\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Access to dedicated instructions 
.SH "Macro Definition Documentation"
.PP 
.SS "#define __BKPT(value)   __breakpoint(value)"

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.SS "#define __BKPT(value)   \fB__ASM\fP volatile ('bkpt '#value)"

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.SS "#define __BKPT(value)   \fB__ASM\fP volatile ('bkpt '#value)"

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.SS "#define __CLZ   __clz"

.PP
Count leading zeros\&. Counts the number of leading zeros of a data value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to count the leading zeros 
.RE
.PP
\fBReturns:\fP
.RS 4
number of leading zeros in value 
.RE
.PP

.SS "#define __CLZ   (uint8_t)__builtin_clz"

.PP
Count leading zeros\&. Counts the number of leading zeros of a data value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to count the leading zeros 
.RE
.PP
\fBReturns:\fP
.RS 4
number of leading zeros in value 
.RE
.PP

.SS "#define __CLZ   (uint8_t)__builtin_clz"

.PP
Count leading zeros\&. Counts the number of leading zeros of a data value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to count the leading zeros 
.RE
.PP
\fBReturns:\fP
.RS 4
number of leading zeros in value 
.RE
.PP

.SS "#define __CMSIS_GCC_OUT_REG(r)   '=r' (r)"

.SS "#define __CMSIS_GCC_OUT_REG(r)   '=r' (r)"

.SS "#define __CMSIS_GCC_RW_REG(r)   '+r' (r)"

.SS "#define __CMSIS_GCC_USE_REG(r)   'r' (r)"

.SS "#define __CMSIS_GCC_USE_REG(r)   'r' (r)"

.SS "#define __DMB(void)"
\fBValue:\fP
.PP
.nf
do {\
                   __schedule_barrier();\
                   __dmb(0xF);\
                   __schedule_barrier();\
                } while (0U)
.fi
.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.SS "#define __DMB(void)   __builtin_arm_dmb(0xF);"

.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.SS "#define __DSB(void)"
\fBValue:\fP
.PP
.nf
do {\
                   __schedule_barrier();\
                   __dsb(0xF);\
                   __schedule_barrier();\
                } while (0U)
.fi
.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.SS "#define __DSB(void)   __builtin_arm_dsb(0xF);"

.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.SS "#define __ISB(void)"
\fBValue:\fP
.PP
.nf
do {\
                   __schedule_barrier();\
                   __isb(0xF);\
                   __schedule_barrier();\
                } while (0U)
.fi
.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.SS "#define __ISB(void)   __builtin_arm_isb(0xF);"

.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.SS "#define __NOP   __nop"

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.SS "#define __NOP   __builtin_arm_nop"

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.SS "#define __NOP()   \fB__ASM\fP volatile ('nop')"

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.SS "#define __RBIT   __builtin_arm_rbit"

.PP
Reverse bit order of value\&. Reverses the bit order of the given value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "#define __REV   __rev"

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "#define __REV(value)   __builtin_bswap32(value)"

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "#define __REV16(value)   \fB__ROR\fP(\fB__REV\fP(value), 16)"

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "#define __REVSH(value)   (int16_t)__builtin_bswap16(value)"

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "#define __ROR   __ror"

.PP
Rotate Right in unsigned value (32 bit) Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIop1\fP Value to rotate 
.br
\fIop2\fP Number of Bits to rotate 
.RE
.PP
\fBReturns:\fP
.RS 4
Rotated value 
.RE
.PP

.SS "#define __SEV   __sev"

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.SS "#define __SEV   __builtin_arm_sev"

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.SS "#define __SEV()   \fB__ASM\fP volatile ('sev')"

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.SS "#define __WFE   __wfe"

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.SS "#define __WFE   __builtin_arm_wfe"

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.SS "#define __WFE()   \fB__ASM\fP volatile ('wfe')"

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.SS "#define __WFI   __wfi"

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.SS "#define __WFI   __builtin_arm_wfi"

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.SS "#define __WFI()   \fB__ASM\fP volatile ('wfi')"

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.SH "Function Documentation"
.PP 
.SS "__attribute__ ((section('\&.rev16_text')))"

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "__attribute__ ((section('\&.revsh_text')))"

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "__attribute__ ((always_inline))"

.PP
Reverse bit order of value\&. Unsigned Saturate\&.
.PP
Signed Saturate\&.
.PP
Reverses the bit order of the given value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value
.RE
.PP
Saturates a signed value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (1\&.\&.32) 
.RE
.PP
\fBReturns:\fP
.RS 4
Saturated value
.RE
.PP
Saturates an unsigned value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (0\&.\&.31) 
.RE
.PP
\fBReturns:\fP
.RS 4
Saturated value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP void __DMB (void)"

.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.SS "\fB__STATIC_FORCEINLINE\fP void __DSB (void)"

.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.SS "\fB__STATIC_FORCEINLINE\fP void __ISB (void)"

.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.SS "\fB__STATIC_FORCEINLINE\fP uint32_t __RBIT (uint32_t value)"

.PP
Reverse bit order of value\&. Reverses the bit order of the given value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP uint32_t __REV (uint32_t value)"

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP uint32_t __REV16 (uint32_t value)"

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP int16_t __REVSH (int16_t value)"

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns:\fP
.RS 4
Reversed value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP uint32_t __ROR (uint32_t op1, uint32_t op2)"

.PP
Rotate Right in unsigned value (32 bit) Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIop1\fP Value to rotate 
.br
\fIop2\fP Number of Bits to rotate 
.RE
.PP
\fBReturns:\fP
.RS 4
Rotated value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP int32_t __SSAT (int32_t val, uint32_t sat)"

.PP
Signed Saturate\&. Saturates a signed value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (1\&.\&.32) 
.RE
.PP
\fBReturns:\fP
.RS 4
Saturated value 
.RE
.PP

.SS "\fB__STATIC_FORCEINLINE\fP uint32_t __USAT (int32_t val, uint32_t sat)"

.PP
Unsigned Saturate\&. Saturates an unsigned value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (0\&.\&.31) 
.RE
.PP
\fBReturns:\fP
.RS 4
Saturated value 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "uint32_t sat"
\fBInitial value:\fP
.PP
.nf
{
  if ((sat >= 1U) && (sat <= 32U))
  {
    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
    const int32_t min = -1 - max ;
    if (val > max)
    {
      return max;
    }
    else if (val < min)
    {
      return min;
    }
  }
  return val
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for TP2_G1 from the source code\&.
